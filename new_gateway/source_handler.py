import asyncio
import logging
import re

import can


class InvalidFrame(Exception):
    pass


class SourceHandler:
    """Base class for classes reading CAN messages.
    This serves as a kind of interface for all classes reading CAN messages,
    whatever the source of these messages: serial port, text file etc.
    """

    def open(self):
        raise NotImplementedError

    def close(self):
        raise NotImplementedError

    def get_message(self):
        """Get CAN id and CAN data.
        Returns:
            A tuple containing the id (int) and data (bytes)
        Raises:
            InvalidFrame
        """
        raise NotImplementedError


class CanHandler(SourceHandler):
    """Handler for CAN interface"""

    def __init__(self, device_name):
        self.device_name = device_name
        self.can0 = None
        self.notifier = None
        self.reader = None

    def open(self):
        logging.debug("Open CAN Interface")
        can0 = can.Bus(channel='can0', bustype='socketcan', receive_own_messages=False)
        reader = can.AsyncBufferedReader()
        listeners = [reader]

        loop = asyncio.get_event_loop()
        notifier = can.Notifier(can0, listeners, loop=loop)

        self.can0 = can0
        self.reader = reader
        self.notifier = notifier

    def close(self):
        logging.debug("Close CAN Interface")
        if self.can0:
            self.can0.shutdown()
        if self.notifier:
            self.notifier.stop()

    async def get_message(self):
        message = self.reader.get_message()
        logging.debug("Raw message %s", message)
        return message


class CandumpHandler(SourceHandler):
    """Parser for text files generated by candump."""

    MSG_RE = r"\(([.0-9]+)\).* ([0-9A-F]+)\#([0-9A-F]*)"
    MSG_RGX = re.compile(MSG_RE)

    def __init__(self, file_path):
        self.file_path = file_path
        self.file_object = None

    def open(self):
        logging.debug("Open fake CANDUMP Interface (file)")
        self.file_object = open(self.file_path, 'rt', encoding='utf-8')

    def close(self):
        logging.debug("Close fake CANDUMP Interface (file)")
        if self.file_object:
            self.file_object.close()

    def get_message(self):
        line = self.file_object.readline()
        if line == '':
            raise EOFError
        message = self._parse_from_candump(line)
        logging.debug("Raw message %s", message)
        return message

    async def _parse_from_candump(self, line):
        line = line.strip('\n')

        msg_match = self.MSG_RGX.match(line)
        if msg_match is None:
            raise InvalidFrame("Wrong format: '{}'".format(line))

        can_time, hex_can_id, hex_can_data = msg_match.group(1, 2, 3)
        can_id = int(hex_can_id, 16)

        try:
            can_data = bytes.fromhex(hex_can_data)
        except ValueError as err:
            raise InvalidFrame("Can't decode message '{}': '{}'".format(line, err))

        return can.Message(timestamp=float(can_time), arbitration_id=can_id, data=can_data)
