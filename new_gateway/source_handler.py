import asyncio
from binascii import unhexlify
import re

import can
import serial

import time

from can import Message, Bus


class InvalidFrame(Exception):
    pass


class SourceHandler:
    """Base class for classes reading CAN messages.
    This serves as a kind of interface for all classes reading CAN messages,
    whatever the source of these messages: serial port, text file etc.
    """

    def open(self):
        raise NotImplementedError

    def close(self):
        raise NotImplementedError

    def get_message(self):
        """Get CAN id and CAN data.
        Returns:
            A tuple containing the id (int) and data (bytes)
        Raises:
            InvalidFrame
        """
        raise NotImplementedError


class CanHandler(SourceHandler):

    def __init__(self, device_name):
        self.device_name = device_name
        self.can0 = None
        self.notifier = None
        self.reader = None

    def open(self):
        can0 = can.Bus(channel='can0', bustype='socketcan', receive_own_messages=False)
        reader = can.AsyncBufferedReader()
        listeners = [reader]

        loop = asyncio.get_event_loop()
        notifier = can.Notifier(can0, listeners, loop=loop)

        self.can0 = can0
        self.reader = reader
        self.notifier = notifier

    def close(self):
        if self.can0:
            self.can0.shutdown()
        if self.notifier:
            self.notifier.stop()

    def get_message(self):
        line = await self.reader.get_message()
        return line

    def _read_until_newline(self):
        """Read data from `serial_device` until the next newline character."""
        line = self.serial_device.readline()
        while not line.endswith(b'\n'):
            line = line + self.serial_device.readline()

        return line.strip()


class CandumpHandler(SourceHandler):
    """Parser for text files generated by candump."""

    MSG_RE = r"\(([.0-9]+)\).* ([0-9A-F]+)\#([0-9A-F]*)"
    MSG_RGX = re.compile(MSG_RE)

    def __init__(self, file_path, speed_scale=1.0):
        self.file_path = file_path
        self.file_object = None
        if not speed_scale or speed_scale <= 0.0:
            speed_scale = 1.0
        self.speed_scale = speed_scale
        self.clock = 0

    def open(self):
        # interface name in candump file may contain non-ascii chars so we need utf-8
        self.file_object = open(self.file_path, 'rt', encoding='utf-8')

    def close(self):
        if self.file_object:
            self.file_object.close()

    def get_message(self):
        line = self.file_object.readline()
        if line == '':
            raise EOFError
        return self._parse_from_candump(line)

    def _parse_from_candump(self, line):
        line = line.strip('\n')

        msg_match = self.MSG_RGX.match(line)
        if msg_match is None:
            raise InvalidFrame("Wrong format: '{}'".format(line))

        abstime, hex_can_id, hex_can_data = msg_match.group(1, 2, 3)
        self.clock = float(abstime)

        can_id = int(hex_can_id, 16)

        try:
            can_data = bytes.fromhex(hex_can_data)
        except ValueError as err:
            raise InvalidFrame("Can't decode message '{}': '{}'".format(line, err))

        return Message(timestamp=self.clock, arbitration_id=can_id, data=can_data)
